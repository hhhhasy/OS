# Lab3实验报告

## 练习一、理解基于FIFO的页面替换算法（思考题）

> 描述FIFO页面置换算法下，一个页面从被换入到被换出的过程中，会经过代码里哪些函数/宏的处理（或者说，需要调用哪些函数/宏），并用简单的一两句话描述每个函数在过程中做了什么？

1. **`do_pgfault()`**

   当系统发生缺页异常后，程序会将跳转到该函数进行缺页处理。在该函数中会首先判断出错的虚拟地址在`mm_struct`里是否可用，如果可用：若查找的 `pte` 当前为空（表示该虚拟页没有映射），则调用 `pgdir_alloc_page` 分配物理页并建立页表映射。如果页表项不为空（`*ptep != 0`），使用`swap_in()`函数换入页。

2. **`swap_in()`**

   用来将把已经在页表里面映射过并且当前在磁盘上的页换进内存中。

3. **`swap_out()`**

   当使用`alloc_page`函数已经分配不到内存页的情况下，使用该函数把内存中的页从内存中替换出去。

4. **`get_pte()`**

   从页表中找到指定地址的页表项。

5. **`page_remove_pte()`**

   从页表中删除指定地址的页表项。

6. **`swapfs_write（）`**

   用于将页面写入磁盘。在这里由于需要换出页面，而页面内容如果被修改过那么就与磁盘中的不一致，所以需要将其重新写回磁盘。

7. **`swapfs_read（）`**

   用于将磁盘中的数据写入内存。

8. **`_fifo_swap_out_victim（）`**

   `FIFO`替换方法的核心算法，用来将保存页面队列中最先进来的的内存页替换出去。

9. **`free_page（）`**

   用来将要替换的内存页释放。

10. **`tlb_invalidate（）`**

    在替换内存页或更新页表映射之后用来将`TLB`刷新。



## 练习二、深入理解不同分页模式的工作原理（思考题

> get_pte()函数（位于`kern/mm/pmm.c`）用于在页表中查找或创建页表项，从而实现对指定线性地址对应的物理页的访问和映射操作。这在操作系统中的分页机制下，是实现虚拟内存与物理内存之间映射关系非常重要的内容。
>
> - get_pte()函数中有两段形式类似的代码， 结合sv32，sv39，sv48的异同，解释这两段代码为什么如此相像。
> - 目前get_pte()函数将页表项的查找和页表项的分配合并在一个函数里，你认为这种写法好吗？有没有必要把两个功能拆开？



### sv32，sv39，sv48的异同

#### 1. 页表层级

- **sv32**: 使用两级页表结构，适用于 32 位虚拟地址空间。地址由两部分组成：页目录项（10 位）和页表项（10 位），加上12位偏移。
- **sv39**: 使用三级页表结构，适用于 39 位虚拟地址空间。地址分为3个页目录项（9 位、9 位和9位），加上12位偏移。
- **sv48**: 使用四级页表结构，适用于 48 位虚拟地址空间。地址分为4个页目录项（9 位、9 位、9 位和9位），加上12位偏移。

#### 2. 虚拟地址空间大小

- **sv32**: 支持4 GB（2^32）虚拟地址空间。
- **sv39**: 支持512 GB（2^39）虚拟地址空间。
- **sv48**: 支持256 TB（2^48）虚拟地址空间。

#### 3. 每个页表项大小

在这三种模式下，每个页表项的大小都是**64位**。这种一致性使得页表项结构和标志位保持统一。

#### 4. 页大小

这三种模式默认页大小均为 **4 KB**。不过，RISC-V 架构也允许使用更大的超页（例如 2 MB 或 1 GB），由页表项的级别决定。



### 对相似性的解释

这两段代码分别获取页目录表（一级表）和页表（二级表）的页表项，确保在页表中找到对应的物理页表地址。第一段代码 `pdep1` 负责找到第一级页目录项，如果该项不存在且 `create` 为 `true`，则分配一个新的物理页，建立表项。第二段代码 `pdep0` 负责进入到二级页表项，再次进行存在性检查，不存在时同样创建。sv32，sv39，sv48三种模式在结构上都要求分级逐步访问页表，确保每一级都分配和初始化，但由于这种分级逻辑的页表层级间的主要差异仅在于页表基地址的变化和每一级索引的位宽不同，查找操作的基本流程保持不变：通过逐级索引定位到目标页表项并确保其存在。所以代码中每层级的处理逻辑因此非常相似，这使得每个层级的代码结构几乎一致，只需调整基地址和索引偏移量即可适应不同层级的查找和分配需求。

```c
    pde_t *pdep1 = &pgdir[PDX1(la)];
    if (!(*pdep1 & PTE_V)) {
        struct Page *page;
        if (!create || (page = alloc_page()) == NULL) {
            return NULL;
        }
        set_page_ref(page, 1);
        uintptr_t pa = page2pa(page);
        memset(KADDR(pa), 0, PGSIZE);
        *pdep1 = pte_create(page2ppn(page), PTE_U | PTE_V);
    }

    pde_t *pdep0 = &((pde_t *)KADDR(PDE_ADDR(*pdep1)))[PDX0(la)];

    if (!(*pdep0 & PTE_V)) {
    	struct Page *page;
    	if (!create || (page = alloc_page()) == NULL) {
    		return NULL;
    	}
    	set_page_ref(page, 1);
    	uintptr_t pa = page2pa(page);
    	memset(KADDR(pa), 0, PGSIZE);
        *pdep0 = pte_create(page2ppn(page), PTE_U | PTE_V);
    }
```



### 是否需要拆分`get_pte()`函数中的查找和分配功能？

我们组认为这种写法是很好的，并不需要拆分。这种写法的优点在于，通常我们只会在获取页表项时遇到缺失的情况，尤其是在页表非法或未分配的情况下，才需要进行页表的创建。将查找和分配合并在同一个函数中，可以有效减少代码的重复性和函数调用的开销，降低代码的复杂度，使得整体逻辑更加清晰。因为我们主要关心的是最终一级页表所给出的页，因此这种合并不仅简化了代码，还提高了性能。（还需要扩展）

